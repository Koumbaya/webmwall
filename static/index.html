<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WEBM Viewer</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #111;
      color: #eee;
      --columns: 3;
      overflow: hidden;
    }
    #controls {
      padding: 15px;
      position: fixed;
      top: -80px;
      left: 0;
      right: 0;
      background: rgba(34, 34, 34, 0.95);
      backdrop-filter: blur(10px);
      z-index: 10;
      border-bottom: 1px solid #333;
      color: #eee;
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
      transition: top 0.3s ease;
    }
    #controls.show {
      top: 0;
    }
    #controls-trigger {
      position: fixed;
      top: 10px;
      left: 10px;
      width: 40px;
      height: 40px;
      background: rgba(34, 34, 34, 0.4);
      border: 1px solid #555;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 11;
      transition: all 0.3s ease;
      backdrop-filter: blur(5px);
      opacity: 0.6;
    }
    #controls-trigger:hover {
      background: rgba(68, 68, 68, 0.6);
      transform: rotate(90deg);
    }
    #controls-trigger.hide {
      opacity: 0;
      pointer-events: none;
    }
    .gear-icon {
      width: 20px;
      height: 20px;
      background: url('gear.png') center/contain no-repeat;
      filter: invert(1) brightness(0.9) opacity(0.7);
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .container {
      display: flex;
      gap: 10px;
      padding: 10px;
      margin-top: 0;
      height: 100vh;
      overflow: hidden;
    }
    .column {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow: hidden;
      position: relative;
    }
    .column-content {
      display: flex;
      flex-direction: column;
      gap: 10px;
      transition: transform linear;
      will-change: transform;
    }
    .grid-item {
      width: 100%;
      background: #222;
      flex-shrink: 0;
      border-radius: 4px;
    }
    .grid-item video, .grid-item img {
      width: 100%;
      height: auto;
      display: block;
      object-fit: contain;
      background: #111;
      border-radius: 4px;
    }
    input[type="range"] {
      min-width: 80px;
    }
    button {
      background: #333;
      border: 1px solid #555;
      color: #eee;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    button:hover {
      background: #444;
    }
    button:active {
      background: #555;
    }
    #pauseButton {
      font-size: 16px;
      padding: 6px 10px;
    }
    #muteButton, #pauseButton, #columnUp, #columnDown, #speedUp, #speedDown {
      background: #333;
      border: 1px solid #555;
      color: #eee;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #muteButton img, #pauseButton img, #columnUp img, #columnDown img, #speedUp img, #speedDown img {
      width: 16px;
      height: 16px;
      filter: invert(1) brightness(0.9);
    }
    .filter-button {
      background: #333;
      border: 2px solid transparent;
      padding: 8px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .filter-button:hover {
      background: #444;
    }
    .filter-button.active {
      border-color: #666;
      background: #3a3a3a;
    }
    .filter-button.inactive {
      opacity: 0.4;
    }
    .filter-button img {
      width: 20px;
      height: 20px;
      filter: invert(1) brightness(0.9);
    }
  </style>
</head>
<body>
  <div id="controls">
    <div class="control-group">
      <button id="columnDown"><img src="colminus.png" alt="Remove Column"></button>
      <button id="columnUp"><img src="colplus.png" alt="Add Column"></button>
    </div>

    <div class="control-group">
      <button id="speedDown"><img src="snail.png" alt="Decrease Speed"></button>
      <button id="pauseButton"><img src="pause.png" alt="Pause"></button>
      <button id="speedUp"><img src="hare.png" alt="Increase Speed"></button>
    </div>

    <div class="control-group">
      <button id="muteButton"><img src="mute.png" alt="Mute"></button>
    </div>

    <div class="control-group">
      <div class="filter-button active" id="filterGif">
        <img src="gif.png" alt="GIF">
      </div>
      <div class="filter-button active" id="filterWebm">
        <img src="webm.png" alt="WEBM">
      </div>
      <div class="filter-button active" id="filterMp4">
        <img src="mp4.png" alt="MP4">
      </div>
      <div class="filter-button active" id="filterImages">
        <img src="jpg.png" alt="Images">
      </div>
    </div>
  </div>

  <div id="controls-trigger">
    <div class="gear-icon"></div>
  </div>

  <div class="container" id="videoContainer"></div>

  <script type="module">
    const container = document.getElementById('videoContainer');
    const filterGif = document.getElementById('filterGif');
    const filterWebm = document.getElementById('filterWebm');
    const filterMp4 = document.getElementById('filterMp4');
    const filterImages = document.getElementById('filterImages');
    const speedUpButton = document.getElementById('speedUp');
    const speedDownButton = document.getElementById('speedDown');
    const pauseButton = document.getElementById('pauseButton');
    const columnUpButton = document.getElementById('columnUp');
    const columnDownButton = document.getElementById('columnDown');
    const muteButton = document.getElementById('muteButton');

    let columns = 3;
    let scrollSpeed = 8;
    let columnElements = [];
    let columnContents = [];
    let columnLoading = [];
    let animationFrameId = null;
    let isScrolling = false;
    let isMuted = true;

    speedUpButton.addEventListener('click', () => {
      scrollSpeed = Math.min(scrollSpeed + 1, 100);
      updateScrollSpeed();
    });

    speedDownButton.addEventListener('click', () => {
      scrollSpeed = Math.max(scrollSpeed - 1, 0);
      updateScrollSpeed();
    });

    pauseButton.addEventListener('click', () => {
      if (isScrolling) {
        stopScrolling();
        pauseButton.innerHTML = '<img src="play.png" alt="Play">';
      } else {
        startScrolling();
        pauseButton.innerHTML = '<img src="pause.png" alt="Pause">';
      }
    });

    columnUpButton.addEventListener('click', () => {
      columns = Math.min(columns + 1, 6);
      resetGrid();
    });

    columnDownButton.addEventListener('click', () => {
      columns = Math.max(columns - 1, 1);
      resetGrid();
    });

    muteButton.addEventListener('click', () => {
      isMuted = !isMuted;
      muteButton.innerHTML = isMuted ? '<img src="mute.png" alt="Mute">' : '<img src="unmute.png" alt="Unmute">';

      // Toggle mute for all videos
      document.querySelectorAll('video').forEach(video => {
        video.muted = isMuted;
      });
    });

    function getFilters() {
      const filters = [];
      if (filterGif.classList.contains('active')) filters.push('gif');
      if (filterWebm.classList.contains('active')) filters.push('webm');
      if (filterMp4.classList.contains('active')) filters.push('mp4');
      if (filterImages.classList.contains('active')) filters.push('jpg', 'png', 'bmp', 'jpeg');
      return filters;
    }

    function resetGrid() {
      stopScrolling();
      container.innerHTML = '';
      columnElements = [];
      columnContents = [];
      columnLoading = [];

      for (let i = 0; i < columns; i++) {
        const column = document.createElement('div');
        column.className = 'column';

        const columnContent = document.createElement('div');
        columnContent.className = 'column-content';

        column.appendChild(columnContent);
        container.appendChild(column);

        columnElements[i] = column;
        columnContents[i] = columnContent;
        columnLoading[i] = false;

        // Preload items for each column
        loadInitialItems(i);
      }

      startScrolling();
    }

    async function loadInitialItems(columnIndex) {
      const itemsToLoad = Math.ceil(window.innerHeight / 200) + 10; // Load enough items to fill screen plus buffer
      const scrollUp = columnIndex % 2 === 0;

      for (let j = 0; j < itemsToLoad; j++) {
        await addNewItemToColumn(columnIndex, !scrollUp, true);
      }

      if (!scrollUp) {
        // For columns scrolling down, we need to set an initial negative transform
        // so the "top" of the content is off-screen up, and it can scroll down.
        const content = columnContents[columnIndex];
        const totalHeight = Array.from(content.children).reduce((acc, child) => acc + child.offsetHeight + 10, 0);
        const initialY = -(totalHeight - columnElements[columnIndex].offsetHeight);
        content.style.transform = `translateY(${initialY}px)`;
      }
    }

    async function fetchRandomFile() {
      const filters = getFilters();
      const filterParam = filters.length > 0 ? `&types=${filters.join(',')}` : '';
      const res = await fetch(`/api/videos?page=0&limit=1${filterParam}`);
      const urls = await res.json();
      return urls[0];
    }

    function createGridItem(url) {
      const item = document.createElement('div');
      item.className = 'grid-item';

      if (url.endsWith('.webm') || url.endsWith('.mp4')) {
        const video = document.createElement('video');
        video.src = url;
        video.loop = true;
        video.autoplay = true;
        video.muted = isMuted;
        item.appendChild(video);
      } else {
        const img = document.createElement('img');
        img.src = url;
        item.appendChild(img);
      }

      return item;
    }

    async function addNewItemToColumn(columnIndex, addToTop = false, isInitialLoad = false) {
      if (columnLoading[columnIndex]) return;
      columnLoading[columnIndex] = true;

      try {
        const url = await fetchRandomFile();
        const item = createGridItem(url);
        const content = columnContents[columnIndex];

        const mediaElement = item.querySelector('img, video');
        if (mediaElement) {
            try {
                if (mediaElement.tagName === 'IMG') {
                    await new Promise((resolve, reject) => {
                        mediaElement.onload = resolve;
                        mediaElement.onerror = reject;
                    });
                } else if (mediaElement.tagName === 'VIDEO') {
                    await new Promise((resolve, reject) => {
                        mediaElement.onloadedmetadata = resolve;
                        mediaElement.onerror = reject;
                    });
                }
            } catch (e) {
                console.error("Media failed to load", e);
            }
        }

        if (addToTop) {
          if (!isInitialLoad) {
            content.style.transition = 'none';
          }

          // Add item to a temporary container to measure its height
          const tempContainer = document.createElement('div');
          tempContainer.style.position = 'absolute';
          tempContainer.style.visibility = 'hidden';
          tempContainer.style.width = columnElements[columnIndex].offsetWidth + 'px';
          document.body.appendChild(tempContainer);
          tempContainer.appendChild(item);
          const itemHeight = item.offsetHeight + 10;
          tempContainer.removeChild(item);
          document.body.removeChild(tempContainer);


          // Get the latest scroll position right before making changes
          const transform = getComputedStyle(content).transform;
          let currentY = 0;
          if (transform !== 'none') {
            const matrix = transform.match(/matrix\(([^)]+)\)/);
            if (matrix) {
              currentY = parseFloat(matrix[1].split(',')[5]) || 0;
            }
          }

          // Adjust scroll position and then insert the item
          content.style.transform = `translateY(${currentY - itemHeight}px)`;
          content.insertBefore(item, content.firstChild);

          if (!isInitialLoad) {
            content.offsetHeight;
            content.style.transition = 'transform linear';
          }

        } else {
          content.appendChild(item);
        }
      } catch (error) {
        console.error('Failed to add item to column:', error);
      } finally {
        columnLoading[columnIndex] = false;
      }
    }

    function updateScrollSpeed() {
      // No need to restart scrolling, just update the speed
    }

    function startScrolling() {
      if (isScrolling || scrollSpeed === 0) return;

      isScrolling = true;
      scrollAllColumns();
    }

    function stopScrolling() {
      isScrolling = false;
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    }

    function scrollAllColumns() {
      if (!isScrolling) return;

      const step = () => {
        if (!isScrolling) return;

        // Process all columns in the same frame to keep them synchronized
        columnContents.forEach((content, columnIndex) => {
          const column = columnElements[columnIndex];

          if (!content || !column) return;

          // Get current transform
          const transform = getComputedStyle(content).transform;
          let currentY = 0;

          if (transform !== 'none') {
            const matrix = transform.match(/matrix\(([^)]+)\)/);
            if (matrix) {
              const values = matrix[1].split(',');
              currentY = parseFloat(values[5]) || 0;
            }
          }

          const scrollAmount = (scrollSpeed / 10);
          const scrollUp = columnIndex % 2 === 0;

          if (scrollUp) {
            // Scrolling UP
            let newY = currentY - scrollAmount;
            content.style.transform = `translateY(${newY}px)`;

            const firstChild = content.firstElementChild;
            if (firstChild) {
              const itemRect = firstChild.getBoundingClientRect();
              const columnRect = column.getBoundingClientRect();

              if (itemRect.bottom < columnRect.top - 100) {
                const itemHeight = firstChild.offsetHeight + 10;
                content.removeChild(firstChild);

                // When an item is removed from the top, the whole content block shifts up.
                // We need to adjust the transform downward by the same amount to compensate.
                newY += itemHeight;
                content.style.transform = `translateY(${newY}px)`;

                addNewItemToColumn(columnIndex, false); // Add to bottom
              }
            }
          } else {
            // Scrolling DOWN
            let newY = currentY + scrollAmount;
            content.style.transform = `translateY(${newY}px)`;

            const lastChild = content.lastElementChild;
            if (lastChild) {
              const itemRect = lastChild.getBoundingClientRect();
              const columnRect = column.getBoundingClientRect();

              if (itemRect.top > columnRect.bottom + 100) {
                content.removeChild(lastChild);
                addNewItemToColumn(columnIndex, true); // Add to top
              }
            }
          }

          // Ensure we always have enough items in the column
          if (content.children.length < 5 && !columnLoading[columnIndex]) {
            addNewItemToColumn(columnIndex, !scrollUp);
          }
        });

        // Continue the animation
        animationFrameId = requestAnimationFrame(step);
      };

      step();
    }

    // Handle filter changes
    [filterGif, filterWebm, filterMp4, filterImages].forEach(filter => {
      filter.addEventListener('click', () => {
        filter.classList.toggle('active');
        resetGrid();
      });
    });

    // Handle keyboard controls
    document.addEventListener('keydown', (event) => {
      if (event.code === 'Space') {
        event.preventDefault(); // Prevent page scroll
        if (isScrolling) {
          stopScrolling();
          pauseButton.innerHTML = '<img src="play.png" alt="Play">';
        } else {
          startScrolling();
          pauseButton.innerHTML = '<img src="pause.png" alt="Pause">';
        }
      }
    });

    // Handle visibility change to pause/resume scrolling
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        stopScrolling();
      } else {
        startScrolling();
      }
    });

    // Handle controls visibility
    const controlsTrigger = document.getElementById('controls-trigger');
    const controls = document.getElementById('controls');

    controlsTrigger.addEventListener('mouseenter', () => {
      controls.classList.add('show');
      controlsTrigger.classList.add('hide');
    });

    controls.addEventListener('mouseleave', () => {
      controls.classList.remove('show');
      controlsTrigger.classList.remove('hide');
    });

    controlsTrigger.addEventListener('mouseleave', () => {
      // Add a small delay to prevent flickering when moving to controls
      setTimeout(() => {
        if (!controls.matches(':hover')) {
          controls.classList.remove('show');
          controlsTrigger.classList.remove('hide');
        }
      }, 100);
    });

    // Initialize
    resetGrid();
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WEBM Viewer</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #111;
      color: #eee;
      --columns: 3;
      overflow: hidden;
    }
    #controls {
      padding: 10px;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: #222;
      z-index: 10;
      border-bottom: 1px solid #333;
      color: #eee;
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .container {
      display: flex;
      gap: 10px;
      padding: 10px;
      margin-top: 10px;
      height: calc(100vh - 80px);
      overflow: hidden;
    }
    .column {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow: hidden;
      position: relative;
    }
    .column-content {
      display: flex;
      flex-direction: column;
      gap: 10px;
      transition: transform linear;
      will-change: transform;
    }
    .grid-item {
      width: 100%;
      border-radius: 16px;
      background: #222;
      flex-shrink: 0;
    }
    .grid-item video, .grid-item img {
      width: 100%;
      height: auto;
      display: block;
      object-fit: contain;
      background: #111;
      border-radius: 16px;
    }
    input[type="range"] {
      min-width: 80px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <div class="control-group">
      <label for="count">Columns: <span id="countLabel">3</span></label>
      <input type="range" min="1" max="6" value="3" id="count" />
    </div>

    <div class="control-group">
      <label for="speedSlider">Speed: <span id="speedLabel">8</span></label>
      <input type="range" min="0" max="50" value="8" id="speedSlider" />
    </div>

    <div class="control-group">
      <input type="checkbox" id="filterGif" checked />
      <label for="filterGif">GIF</label>

      <input type="checkbox" id="filterWebm" checked />
      <label for="filterWebm">WEBM</label>

      <input type="checkbox" id="filterMp4" checked />
      <label for="filterMp4">MP4</label>

      <input type="checkbox" id="filterImages" checked />
      <label for="filterImages">Images</label>
    </div>
  </div>

  <div class="container" id="videoContainer"></div>

  <script type="module">
    const container = document.getElementById('videoContainer');
    const columnSlider = document.getElementById('count');
    const countLabel = document.getElementById('countLabel');
    const speedSlider = document.getElementById('speedSlider');
    const speedLabel = document.getElementById('speedLabel');
    const filterGif = document.getElementById('filterGif');
    const filterWebm = document.getElementById('filterWebm');
    const filterMp4 = document.getElementById('filterMp4');
    const filterImages = document.getElementById('filterImages');

    let columns = parseInt(columnSlider.value);
    let scrollSpeed = parseInt(speedSlider.value);
    let columnElements = [];
    let columnContents = [];
    let animationFrameId = null;
    let isScrolling = false;

    columnSlider.addEventListener('input', () => {
      columns = parseInt(columnSlider.value);
      countLabel.textContent = columnSlider.value;
      resetGrid();
    });

    speedSlider.addEventListener('input', () => {
      scrollSpeed = parseInt(speedSlider.value);
      speedLabel.textContent = speedSlider.value;
      updateScrollSpeed();
    });

    function getFilters() {
      const filters = [];
      if (filterGif.checked) filters.push('gif');
      if (filterWebm.checked) filters.push('webm');
      if (filterMp4.checked) filters.push('mp4');
      if (filterImages.checked) filters.push('jpg', 'png');
      return filters;
    }

    function resetGrid() {
      stopScrolling();
      container.innerHTML = '';
      columnElements = [];
      columnContents = [];

      for (let i = 0; i < columns; i++) {
        const column = document.createElement('div');
        column.className = 'column';

        const columnContent = document.createElement('div');
        columnContent.className = 'column-content';

        column.appendChild(columnContent);
        container.appendChild(column);

        columnElements[i] = column;
        columnContents[i] = columnContent;

        // Preload items for each column
        loadInitialItems(i);
      }

      startScrolling();
    }

    async function loadInitialItems(columnIndex) {
      const itemsToLoad = Math.ceil(window.innerHeight / 200) + 10; // Load enough items to fill screen plus buffer

      for (let j = 0; j < itemsToLoad; j++) {
        await addNewItemToColumn(columnIndex);
      }
    }

    async function fetchRandomFile() {
      const filters = getFilters();
      const filterParam = filters.length > 0 ? `&types=${filters.join(',')}` : '';
      const res = await fetch(`/api/videos?page=0&limit=1${filterParam}`);
      const urls = await res.json();
      return urls[0];
    }

    function createGridItem(url) {
      const item = document.createElement('div');
      item.className = 'grid-item';

      if (url.endsWith('.webm') || url.endsWith('.mp4')) {
        const video = document.createElement('video');
        video.src = url;
        video.loop = true;
        video.autoplay = true;
        video.muted = true;
        item.appendChild(video);
      } else {
        const img = document.createElement('img');
        img.src = url;
        item.appendChild(img);
      }

      return item;
    }

    async function addNewItemToColumn(columnIndex) {
      try {
        const url = await fetchRandomFile();
        const item = createGridItem(url);
        columnContents[columnIndex].appendChild(item);
      } catch (error) {
        console.error('Failed to add item to column:', error);
      }
    }

    function updateScrollSpeed() {
      // No need to restart scrolling, just update the speed
    }

    function startScrolling() {
      if (isScrolling || scrollSpeed === 0) return;

      isScrolling = true;
      scrollAllColumns();
    }

    function stopScrolling() {
      isScrolling = false;
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    }

    function scrollAllColumns() {
      if (!isScrolling) return;

      const step = () => {
        if (!isScrolling) return;

        // Process all columns in the same frame to keep them synchronized
        columnContents.forEach((content, columnIndex) => {
          const column = columnElements[columnIndex];

          if (!content || !column) return;

          // Get current transform
          const transform = getComputedStyle(content).transform;
          let currentY = 0;

          if (transform !== 'none') {
            const matrix = transform.match(/matrix\(([^)]+)\)/);
            if (matrix) {
              const values = matrix[1].split(',');
              currentY = parseFloat(values[5]) || 0;
            }
          }

          // Calculate new position
          const scrollAmount = (scrollSpeed / 10); // Adjust scroll amount based on speed
          const newY = currentY - scrollAmount;

          content.style.transform = `translateY(${newY}px)`;

          // Check if we need to remove items that have scrolled out of view
          const firstChild = content.firstElementChild;
          if (firstChild) {
            const itemRect = firstChild.getBoundingClientRect();
            const columnRect = column.getBoundingClientRect();

            // If the item has completely scrolled out of view (with some buffer)
            if (itemRect.bottom < columnRect.top - 100) {
              // Get the height BEFORE removing the element
              const itemHeight = firstChild.offsetHeight + 10; // 10px gap

              content.removeChild(firstChild);

              // Adjust transform to account for removed item
              content.style.transform = `translateY(${newY + itemHeight}px)`;

              // Add a new item to the bottom
              addNewItemToColumn(columnIndex);
            }
          }

          // Ensure we always have enough items in the column
          if (content.children.length < 5) {
            addNewItemToColumn(columnIndex);
          }
        });

        // Continue the animation
        animationFrameId = requestAnimationFrame(step);
      };

      step();
    }

    // Handle filter changes
    [filterGif, filterWebm, filterMp4, filterImages].forEach(filter => {
      filter.addEventListener('change', () => {
        resetGrid();
      });
    });

    // Handle visibility change to pause/resume scrolling
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        stopScrolling();
      } else {
        startScrolling();
      }
    });

    // Initialize
    resetGrid();
  </script>
</body>
</html>
